1) openCV images coordinates are y,x or height, width
2) OpenCV 0,0 is upper left corner
3) In Translation Negative values move left and up, positive move right, and down.

Define a translation matrix to shift an image 30 pixels up and 50 pixels to the right.
M = np.float32([[1, 0, 50], [0, 1, -30]])

Define a translation matrix to shift an image 90 pixels down and 10 pixels to to the left.
M = np.float32([[1, 0, 50], [0, 1, 90]])

4) In Rotation Negative numbers is clockwise and positive numbers are counter clockwise
5) general rule, cv2.INTER_LINEAR  interpolation method is recommended as the default for whenever you’re upsampling or downsampling

6) when using flip 1 is horizontal, 0 is vertical, and -1 is both horizontal and vertical flipping.

7) Bitwise on is greater than 0, off = 0.
    AND: A bitwise AND is true if and only if both pixels are greater than zero.
    OR: A bitwise OR is true if either of the two pixels are greater than zero.
    XOR: A bitwise XOR is true if and only if one of the two pixels is greater than zero, but not both.
    NOT: A bitwise NOT inverts the “on” and “off” pixels in an image.
8) Essentially, the bitwise NOT function flips pixel values

9) Kernels can be an arbitrary size of M \times N pixels, provided that both M and N are odd integers.

10) as the size of the kernel increases, so will the amount in which the image is blurred.
11) always consider your lighting conditions before you write a single line of code!

12) We could also use the Scharr kernel instead of the Sobel kernel which may give us better approximations to the gradient

Note: While it’s not present in the code sample above, computing the Scharr kernel can be done in the exact same manner,
 only using the cv2.Scharr  function or supplying an optional parameter value of ksize=-1 for the cv2.Sobel  function
    # compute gradients along the X and Y axis, respectively
    gX = cv2.Sobel(gray, ddepth=cv2.CV_64F, dx=1, dy=0)
    gY = cv2.Sobel(gray, ddepth=cv2.CV_64F, dx=0, dy=1)